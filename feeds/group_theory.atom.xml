<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Notes</title><link href="http://dandavison.github.io/notes/" rel="alternate"></link><link href="http://dandavison.github.io/notes/feeds/group_theory.atom.xml" rel="self"></link><id>http://dandavison.github.io/notes/</id><updated>2016-12-05T00:00:00-08:00</updated><entry><title>Examples of groups</title><link href="http://dandavison.github.io/notes/examples-of-groups.html" rel="alternate"></link><published>2016-12-05T00:00:00-08:00</published><author><name>Dan Davison</name></author><id>tag:dandavison.github.io,2016-12-05:notes/examples-of-groups.html</id><summary type="html">&lt;div class="math"&gt;$$
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
$$&lt;/div&gt;
&lt;h3 id="examples-of-groups"&gt;Examples of groups&lt;/h3&gt;
&lt;h3 id="finite-order"&gt;Finite order&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(S_2\)&lt;/span&gt;: the set of permutations of two objects, where the operation is
  composition of functions.  There are just two elements in the group: the
  do-nothing permutation and the switch-the-elements permutation: &lt;span class="math"&gt;\(\{e,
  \tau\}\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(S_3\)&lt;/span&gt;: the set of permutations of three objects. There are 6 elements: the
  identity, 3 transitions&lt;sup id="sf-examples-of-groups-1-back"&gt;&lt;a href="#sf-examples-of-groups-1" class="simple-footnote" title="A transition is a permutation that switches two   elements and leaves all other alone"&gt;1&lt;/a&gt;&lt;/sup&gt; and two cyclic permutations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\{1, i, -1, -i\}\)&lt;/span&gt; where the operation is multiplication of complex numbers.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(GL_n(\R)\)&lt;/span&gt;: the set of &lt;span class="math"&gt;\(n \times n\)&lt;/span&gt; matrices, under matrix multiplication.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(SL_n(\R)\)&lt;/span&gt;: set of &lt;span class="math"&gt;\(n \times n\)&lt;/span&gt; matrices with determinant &lt;span class="math"&gt;\(1\)&lt;/span&gt; (kernel of the
  determinant homomorphism &lt;span class="math"&gt;\(GL_n(\R) \rightarrow \R^x\)&lt;/span&gt; and therefore a normal
  subgroup of &lt;span class="math"&gt;\(GL_n(\R)\)&lt;/span&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="infinite-order"&gt;Infinite order&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\Z^+\)&lt;/span&gt; integers under addition&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\Z^x\)&lt;/span&gt; integers under multiplication&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\Z_{&amp;gt;0}^+\)&lt;/span&gt; positive integers under addition&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Similarly, &lt;span class="math"&gt;\(\Q+\)&lt;/span&gt;, &lt;span class="math"&gt;\(\Q^x\)&lt;/span&gt;, &lt;span class="math"&gt;\(\C^+\)&lt;/span&gt;, &lt;span class="math"&gt;\(\C^x\)&lt;/span&gt;, &lt;span class="math"&gt;\(\R^+\)&lt;/span&gt;, &lt;span class="math"&gt;\(\R^x\)&lt;/span&gt; etc&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;ol class="simple-footnotes"&gt;&lt;li id="sf-examples-of-groups-1"&gt;A transition is a permutation that switches two
  elements and leaves all other alone &lt;a href="#sf-examples-of-groups-1-back" class="simple-footnote-back"&gt;â†©&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</summary></entry><entry><title>Group Theory (Misc)</title><link href="http://dandavison.github.io/notes/group-theory-misc.html" rel="alternate"></link><published>2016-12-05T00:00:00-08:00</published><author><name>Dan Davison</name></author><id>tag:dandavison.github.io,2016-12-05:notes/group-theory-misc.html</id><summary type="html">&lt;p&gt;The equivalent in linear algebra is: if a linear transformation sends two
vectors to the same place, then one of the vectors can be expressed as the
other plus some vector in the nullspace. I.e. adding a vector from the
nullspace makes no difference to to where you are sent, and furthermore, that
is the only way two vectors can end up being sent to the same place.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src="/notes/images/group-theory/fibres-and-congruence-classes.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;The kernel of a homomorphism is a normal subgroup.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The structure-preserving property means that the element being conjugated
disappears leaving the conjugating elements to cancel each other out:&lt;/p&gt;
&lt;div class="math"&gt;$$
\varphi(gag^{-1}) = \varphi(g)\varphi(a)\varphi(g^{-1}) = \varphi(g)1\varphi(g)^{-1} = 1
$$&lt;/div&gt;
&lt;hr /&gt;
&lt;p&gt;Whether or not a map is a homomorphism, and what its kernel is, depend on what
the group operation in the codomain is. So you can find normal subgroups of a
group &lt;span class="math"&gt;\(G\)&lt;/span&gt; by considering codomains and codomain operations and determining
their kernel.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;span class="math"&gt;\(A_n\)&lt;/span&gt; is a normal subgroup of &lt;span class="math"&gt;\(S_n\)&lt;/span&gt;. What is &lt;span class="math"&gt;\(A_n\)&lt;/span&gt;? OK it's to do with
permutations and permutation matrices. Read that bit of ch 1.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;For finite groups, the following words have basically the same meaning:
- bijective function
- permutation
-&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Note that in the first two examples, the elements being composed are numbers or
matrices: they are not themselves functions. However, in &lt;span class="math"&gt;\(S_2\)&lt;/span&gt; and &lt;span class="math"&gt;\(S_3\)&lt;/span&gt;, the
&lt;em&gt;elements&lt;/em&gt; being composed are already function-like objects (a permutation of
&lt;span class="math"&gt;\(n\)&lt;/span&gt; objects is a bijection from the set to itself).&lt;/p&gt;
&lt;p&gt;Hang on, is that true? Both multiplication by a complex number, and matrix
multiplication, can be viewed as composition of functions (a complex number
rotates and scales the complex plane, and a matrix is a linear transformation).&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary></entry><entry><title>Group Theory</title><link href="http://dandavison.github.io/notes/group-theory.html" rel="alternate"></link><published>2016-12-04T00:00:00-08:00</published><author><name>Dan Davison</name></author><id>tag:dandavison.github.io,2016-12-04:notes/group-theory.html</id><summary type="html">&lt;div class="math"&gt;$$
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
$$&lt;/div&gt;
&lt;p&gt;A group is a set, together with an operation that can be performed on two elements to produce another element.&lt;/p&gt;
&lt;p&gt;Concrete examples of groups:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\{1, i, -1, -i\}\)&lt;/span&gt; where the operation is multiplication of complex numbers.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(GL_n(\R)\)&lt;/span&gt;: the set of &lt;span class="math"&gt;\(n \times n\)&lt;/span&gt; matrices, under matrix multiplication.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(S_2\)&lt;/span&gt;: the set of permutations of two objects, where the operation is
  composition of functions.  There are just two elements in the group: the
  do-nothing permutation and the switch-the-elements permutation: &lt;span class="math"&gt;\(\{e,
  \tau\}\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(S_3\)&lt;/span&gt;: the set of permutations of three objects. There are 6 elements: the
  identity, 3 transitions&lt;sup id="sf-group-theory-1-back"&gt;&lt;a href="#sf-group-theory-1" class="simple-footnote" title="A transition is a permutation that switches two   elements and leaves all other alone"&gt;1&lt;/a&gt;&lt;/sup&gt; and two cyclic permutations.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A &lt;strong&gt;homomorphism&lt;/strong&gt; is a map&lt;sup id="sf-group-theory-2-back"&gt;&lt;a href="#sf-group-theory-2" class="simple-footnote" title='"map" is a synonym of "function".'&gt;2&lt;/a&gt;&lt;/sup&gt; from
one group to another. If it is bijective, it is an &lt;strong&gt;isomorphism&lt;/strong&gt;. If it is
bijective and from a group to itself (i.e. a permutation of the group elements)
then it is an &lt;strong&gt;automorphism&lt;/strong&gt;. The critical feature of these concepts is that
they "preserve group structure", i.e. they preserve the relationships among
group elements defined by the group operation. Suppose that they map from group
&lt;span class="math"&gt;\(G\)&lt;/span&gt; to group &lt;span class="math"&gt;\(G'\)&lt;/span&gt;. Then the preservation-of-structure criterion is that the map
sends a product &lt;span class="math"&gt;\(g_1 \circ g_2\)&lt;/span&gt; to the product of whatever the separate
elements are sent to:&lt;/p&gt;
&lt;div class="math"&gt;$$
f(g_1 \circ g_2) = f(g_1) \circ f(g_2)
$$&lt;/div&gt;
&lt;p&gt;There the composition on the left is happening in &lt;span class="math"&gt;\(G\)&lt;/span&gt; and the composition on
the right is happening in &lt;span class="math"&gt;\(G'\)&lt;/span&gt;. (For an automorphism, &lt;span class="math"&gt;\(G=G'\)&lt;/span&gt;.)&lt;/p&gt;
&lt;p&gt;Note that an element such as &lt;span class="math"&gt;\(g_1\)&lt;/span&gt; that is being sent somewhere by a morphism
may itself already be a map of sorts, e.g. if it is a permutation in
&lt;span class="math"&gt;\(S_3\)&lt;/span&gt;. This is potentially confusing, since an automorphism can be thought of
as a permutation of group elements. So an automorphism on &lt;span class="math"&gt;\(S_3\)&lt;/span&gt; is a
permutation of group elements that are themselves permutations of some generic
labeled objects.&lt;/p&gt;
&lt;p&gt;The definition of homomorphism implies that &lt;span class="math"&gt;\(f(g^{-1}) = f(g)^{-1}\)&lt;/span&gt; since
&lt;span class="math"&gt;\(f(gg^{-1}) = f(g)f(g^{-1}) = f(e)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3 id="kernel-nullspace-bijection-and-congruency"&gt;Kernel, nullspace, bijection and congruency&lt;/h3&gt;
&lt;p&gt;Consider a homomorphism &lt;span class="math"&gt;\(f\)&lt;/span&gt; with kernel &lt;span class="math"&gt;\(N\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theorem:&lt;/strong&gt; &lt;span class="math"&gt;\(a\)&lt;/span&gt; and &lt;span class="math"&gt;\(b\)&lt;/span&gt; are sent to the same place by &lt;span class="math"&gt;\(f\)&lt;/span&gt; if and only if
&lt;span class="math"&gt;\(b = an\)&lt;/span&gt; for some &lt;span class="math"&gt;\(n \in N\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Corollary:&lt;/strong&gt; &lt;span class="math"&gt;\(f\)&lt;/span&gt; is a bijection (isomorphism) if and only if the kernel
contains only the identity element.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt; Consider the absolute value homomorphism mapping complex numbers
under multiplication to positive reals under multiplication. The equivalence
classes are concentric circles around the origin. Two complex numbers have the
same absolute value iff one can be obtained from the other by rotation only (no
scaling). This is multiplication by a complex number with absolute value 1, and
such a complex number is in the kernel.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt; Clearly, if &lt;span class="math"&gt;\(b = an\)&lt;/span&gt; then &lt;span class="math"&gt;\(b\)&lt;/span&gt; is sent to the same place as &lt;span class="math"&gt;\(a\)&lt;/span&gt;,
since&lt;/p&gt;
&lt;div class="math"&gt;$$
f(b) = f(an) = f(a)f(n) = f(a).
$$&lt;/div&gt;
&lt;p&gt;However we need to demonstrate the converse, i.e. that the &lt;em&gt;only&lt;/em&gt; way that &lt;span class="math"&gt;\(b\)&lt;/span&gt;
can be sent to the same place as &lt;span class="math"&gt;\(a\)&lt;/span&gt; is if &lt;span class="math"&gt;\(b=an\)&lt;/span&gt; for some &lt;span class="math"&gt;\(n \in N\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Two almost identical ways of showing that:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) Show that if &lt;span class="math"&gt;\(f(a) = f(b)\)&lt;/span&gt; then &lt;span class="math"&gt;\(b = an\)&lt;/span&gt; for some &lt;span class="math"&gt;\(n \in N\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In linear algebra, you can always get from &lt;span class="math"&gt;\(u\)&lt;/span&gt; to &lt;span class="math"&gt;\(v\)&lt;/span&gt; by adding &lt;span class="math"&gt;\(v - u = -u +
v\)&lt;/span&gt;, so the claim is that &lt;span class="math"&gt;\(L(u) = L(v)\)&lt;/span&gt; implies &lt;span class="math"&gt;\(-u + v\)&lt;/span&gt; is in the nullspace,
which is true:&lt;/p&gt;
&lt;div class="math"&gt;$$
L(-u + v) = L(-u) + L(v) = L(-u) + L(u) = 0.
$$&lt;/div&gt;
&lt;p&gt;For a group homomorphism, &lt;span class="math"&gt;\(b\)&lt;/span&gt; can be written as &lt;span class="math"&gt;\(aa^{-1}b\)&lt;/span&gt;, so the claim is
that &lt;span class="math"&gt;\(f(a) = f(b)\)&lt;/span&gt; implies &lt;span class="math"&gt;\(a^{-1}b \in N\)&lt;/span&gt;, which is true:&lt;/p&gt;
&lt;div class="math"&gt;$$
f(a^{-1}b) = f(a^{-1})f(b) = f(a)^{-1}f(a) = e.
$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;(2) Show that if it is not the case that &lt;span class="math"&gt;\(b = an\)&lt;/span&gt; for some &lt;span class="math"&gt;\(n \in N\)&lt;/span&gt;, then &lt;span class="math"&gt;\(f(a) \neq f(b)\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In linear algebra, you can always get from &lt;span class="math"&gt;\(u\)&lt;/span&gt; to &lt;span class="math"&gt;\(v\)&lt;/span&gt; by adding &lt;span class="math"&gt;\(v - u = -u + v\)&lt;/span&gt;,
so if &lt;span class="math"&gt;\(-u + v\)&lt;/span&gt; is not in the nullspace then&lt;/p&gt;
&lt;div class="math"&gt;$$
L(v) = L(u + (-u + v)) = L(u) + L(-u + v) \neq L(u).
$$&lt;/div&gt;
&lt;p&gt;For a group homomorphism, &lt;span class="math"&gt;\(b\)&lt;/span&gt; can be written as &lt;span class="math"&gt;\(aa^{-1}b\)&lt;/span&gt;, so if &lt;span class="math"&gt;\(a^{-1}b\)&lt;/span&gt; is
not in the kernel then&lt;/p&gt;
&lt;div class="math"&gt;$$
f(b) = f(aa^{-1}b) = f(a)f(a^{-1}b) \neq f(a)
$$&lt;/div&gt;
&lt;h3 id="inverse-of-an-automorphism-is-an-automorphism"&gt;Inverse of an automorphism is an automorphism&lt;/h3&gt;
&lt;p&gt;[Artin 2.3.11: show that Aut(&lt;span class="math"&gt;\(G\)&lt;/span&gt;) is a group]&lt;/p&gt;
&lt;div class="math"&gt;$$
\newcommand{\a}{\alpha}
\newcommand{\ainv}{\alpha^{-1}}
$$&lt;/div&gt;
&lt;p&gt;Suppose &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; is an automorphism that sends &lt;span class="math"&gt;\(g_1\)&lt;/span&gt; and &lt;span class="math"&gt;\(g_2\)&lt;/span&gt; to &lt;span class="math"&gt;\(g_1'\)&lt;/span&gt; and
&lt;span class="math"&gt;\(g_2'\)&lt;/span&gt;, respectively.&lt;/p&gt;
&lt;p&gt;&lt;img width="300 px" src="/notes/images/group-theory/inverse-of-automorphism-1.png"&gt;&lt;/p&gt;
&lt;p&gt;We need to show that &lt;span class="math"&gt;\(\ainv\)&lt;/span&gt; preserves structure, i.e. that when &lt;span class="math"&gt;\(\ainv\)&lt;/span&gt; acts
on an element which is a product, say &lt;span class="math"&gt;\(g_1'g_2'\)&lt;/span&gt;, it sends it to the product of
whatever it send the individual factors to:&lt;/p&gt;
&lt;div class="math"&gt;$$
\ainv(g_1'g_2') = \ainv(g_1')\ainv(g_2').
$$&lt;/div&gt;
&lt;p&gt;Firstly, we know that &lt;span class="math"&gt;\(\ainv(g_1')\)&lt;/span&gt; and &lt;span class="math"&gt;\(\ainv(g_2')\)&lt;/span&gt; exist, i.e. some elements
are taken to them by &lt;span class="math"&gt;\(a\)&lt;/span&gt;, because &lt;span class="math"&gt;\(a\)&lt;/span&gt; is an automorphism and therefore
surjective. So we'll call those &lt;span class="math"&gt;\(g_1\)&lt;/span&gt; and &lt;span class="math"&gt;\(g_2\)&lt;/span&gt;, and the equality we need to
demonstrate has become&lt;/p&gt;
&lt;div class="math"&gt;$$
\ainv(\a(g_1)\a(g_2)) = g_1g_2.
$$&lt;/div&gt;
&lt;p&gt;Since &lt;span class="math"&gt;\(\a\)&lt;/span&gt; is an automorphism, it preserves structure, therefore
&lt;span class="math"&gt;\(\a(g_1)\a(g_2) = \a(g_1g_2)\)&lt;/span&gt;. So,&lt;/p&gt;
&lt;div class="math"&gt;$$
\ainv(\a(g_1)\a(g_2)) = \ainv(\a(g_1g_2)) = g_1g_2,
$$&lt;/div&gt;
&lt;p&gt;as required.&lt;/p&gt;
&lt;hr&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;ol class="simple-footnotes"&gt;&lt;li id="sf-group-theory-1"&gt;A transition is a permutation that switches two
  elements and leaves all other alone &lt;a href="#sf-group-theory-1-back" class="simple-footnote-back"&gt;â†©&lt;/a&gt;&lt;/li&gt;&lt;li id="sf-group-theory-2"&gt;"map" is a synonym of "function". &lt;a href="#sf-group-theory-2-back" class="simple-footnote-back"&gt;â†©&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</summary></entry></feed>